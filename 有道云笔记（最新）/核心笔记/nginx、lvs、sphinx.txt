				
四、nginx 、 apache
	1、nginx:
		1)多进程模式，一个master进程和多个worker进程，
			（1）master进程作用：
				一：接受来自外界的信号
				二：向各worker进程发送信号，监控worker进程状态
				三：如果worker进程异常退出，自动重新启动新worker进程（也就是fork出新的worker进程）
			（2）worker进程作用：
				一、处理来自客户端的请求（多个worker进程之间竞争谁来处理）
		2）多进程好处：
			（1）各个进程相互独立，不会影响彼此，一个进程退出，其它进程服务不会中断，降低了风险
			（2）支持高并发，采用异步非阻塞方式来处理请求
		3）负载均衡（upstream）：
			（1）调度算法：
				一、轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响
				二、weight（权重）：weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下，若后端服务器性能较好则可将weight值设置大点
				三、ip_hash：来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。
				四、fair：服务器响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。
				五、url_hash：使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包
			（2）参数：
				一、down，表示当前的server暂时不参与负载均衡。
				二、backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻
				
		4）反向代理：
			（1）是把一些静态资源存储在服务器上，当用户有请求的时候，就直接返回反向代理服务器上的资源给用户，而如果反向代理服务器上没有的资源，就转发给后面的负载均衡服务器，负载均衡服务器再将请求分发给后端的web服务器，然后把获得的数据存储在反向代理服务器（有点类似于缓存）
			（2）好处：
				一、提升网站性能，加速了网站的访问速，减轻服务器压力
				二、解决了网站服务器对外可见的问题，提高了网站服务器的安全性；
		5）反向代理与负载均衡区别：
			（1）反向代理服务器是需要存储资源的，让用户更快速的接收到资源    
			（2）负载均衡就是，为了保证后端web服务器的高可用，高并发，是不需要要存储资源，只需要转发用户的请求。
		6）正向代理（也就是代理）与反向代理区别：
			（1）正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端（如：蓝灯）
			（2）反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。	
		7）nginx平滑重启：usr/local/nginx/nginx -s reload 
	2、apache:
		1)同步多进程，阻塞型的
	3、nginx与apache相比优缺点：
		1）nginx优点：
			（1）轻量级，比apache占用更少的内存及资源
			（2）抗并发，因为是多进程，处理请求是非阻塞型的
			（3）反向代理及负载均衡	
			（4）高度模块化设计
			（5）静态文件处理性能比apache高3倍以上
		2）apache优点：
			（1）rewrite（重写） ，比nginx 的rewrite 强大
			（2）模块超多，基本想到的都可以找到
			（3）少bug ，nginx 的bug 相对较多，超稳定
			（4）更适合处理动态请求
	4、nginx与apache区别:
		1)nginx是异步多进程，多个连接可以对应一个进程，非阻塞型的
		  apache是同步多进程，一个连接对应一个进程，阻塞型的	
						
				
	
五、sphix、coreseek （全文检索引擎）
	1、适用场景：
		1）当sql全文检索，like全表查询速度比较慢的时候
		2)中文分词
	2、原理：
		1）流程图：Database(数据源)->Indexer(创建/更新索引)->searched(搜索)->客户端	
		2）Sphinx的整个工作流程就是Indexer程序到数据库里面提取数据，对数据进行分词，然后根据生成的分词生成单个或多个索引，并将它们传递给searchd程序。然后客户端可以通过API调用进行搜索。
	3、php中使用sphinx：
		1）php先把要搜索的sql发给shpinx服务器，sphinx返回记录的id,php再用这个id去查询数据库
	4、sphinxse：把sphinx当成插件编译到mysql中去，成为mysql的一部分	
	5、主索引、增量索引、实时索引（因为有数据不断插入与修改，所以要实时更新索引，可以用sphinxRt,一个实时索引的api，rt是real time的简写）



六、lvs+keepalive 、nginx+keepalive
	1、lvs：
		1）LVS是一个开源的软件，可以实现LINUX平台下的简单负载均衡。LVS是Linux Virtual Server的缩写，意思是Linux虚拟服务器。目前有三种IP负载均衡技术（VS/NAT、VS/TUN和VS/DR）；工作在网络第四层（传输层）！
			（1) lvs nat模式：就是把客户端发来的数据包的IP头的目的地址，在负载均衡器上换成其中一台RS的IP地址，并发至此RS来处理,RS处理完成后把数据交给经过负载均衡器,负载均衡器再把数据包的原IP地址改为自己的IP，将目的地址改为客户端IP地址即可。期间,无论是进来的流量,还是出去的流量,都必须经过负载均衡器。（rs：real server）
				一、流程图：客户端<-->负载均衡服务器<-->真实服务器
			（2）DR模式（direct routing）：负载均衡器和RS都使用同一个IP对外服务，但只有DR对ARP请求进行响应,所有RS对本身这个IP的ARP请求保持静默，也就是说,网关会把对这个服务IP的请求全部定向给DR,而DR收到数据包后根据调度算法,找出对应的RS,把目的MAC地址改为RS的MAC（因为IP一致）并将请求分发给这台RS，而真实服务器响应后的处理结果直接返回给客户端用户
				一、流程图：发送：  客户端-->负载均衡服务器-->真实服务器
				二、响应：真实服务器-->客户端
		2）nat模式(Network  address translation)：如果内网使用了一个私有的网络地址段，比如10.x.x.x/172.16.x.x/192.168.x.x，并且需要访问互联网，则路由器需要工作在NAT 模式下。路由器工作在NAT 模式时，内网中的出访数据包的源地址将被转换为路由器WAN 口配置的合法IP地址。通俗的说就是 你的电脑地址不是合法的公网地址，无法在公网传输数据，由拥有合法公网地址的路由器来做一个中介，相互转发内网-外网的数据！
		3）路由模式：你拥有合法的IP地址，根据路由表来判断数据走向访问目的地。
	2、keepalive：
		1）keepalived是集群管理中保证集群高可用的防止单点故障一个服务软件，以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议
		2）虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（virtual_ipaddress虚拟ip）（该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master。这样的话就可以保证路由器的高可用了
		3）keepalived主要有三个模块，分别是core、check和vrrp。core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式。vrrp模块是来实现VRRP协议的
		4）priority 用来选举master的，要成为master，那么这个选项的值最好高于其他机器50个点，该项取值范围是1-255（在此范围之外会被识别成默认值100）
    	3、lvs+keepalive：	
		1）Keepalived 是运行在lvs 之上，它的主要功能是提供健康检查、实现真实机的故障隔离及负载均衡器间的失败切换，提高系统的可用性	
		2）LVS+keepalived能很好的实现负载均衡技术、系统高可用性，LVS提供负载均衡，keepalived提供健康检查，故障转移，提高系统的可用性！采用这样的架构以后 很容易对现有系统进行扩展，只要在后端添加或者减少realserver，只要更改lvs的 配置文件，并能实现无缝配置变更！
    	4、nginx+keepalive主从切换
		1）原理：keepalive启动时加载配置文件中vrrp_script模块一个监控nginx状态的脚本，keepalive根据此脚本得出nginx状态，如果nginx不正常，则尝试恢复启动nginx，如果keepalive最终仍不能恢复NginX则杀掉keepalived，使得从服务器能够接管服务。
		2）步骤：
			（1）两台nginx服务器，一主一从，主从服务器上都安装keepalive，进行相关配置（如：虚拟ip）并启动
			（2）如果主服务器的keepalived停止服务，从服务器会自动接管VIP对外服务；一旦主服务器的keepalived恢复，会重新接管VIP
		3）如何监控NginX的状态：最简单的做法是监控NginX进程，更靠谱的做法是写监控脚本检查NginX端口
		4）让keepalived监控NginX的状态，当NginX主服务器停止服务的时候能够自动切换到从服务器上，实现nginx高可用！
				
    	5、lvs+keepalive 与 nginx+keepalive区别
		1）lvs是第四层（传输层）负载均衡，nginx是第七层（应用层）负载均衡



七、网站安全问题：xss攻击 、csrf攻击 、sql注入
	1、xss攻击:
		1)定义：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。
		2）通俗解释：通过客户端脚本语言（最常见如：JavaScript）在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那么就叫做XSS！
		3）防御方法：
			（1）、前端提交的代码进行过滤（如：php中的htmlentities()或htmlspecialchars()）
	2、csrf攻击：
		1）定义：跨站请求伪造（英语：Cross-site request forgery），通常缩写为 CSRF 或者 XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。
		2）通俗解释：冒充用户发起请求（在用户不知情的情况下）,完成一些违背用户意愿的请求（如恶意发帖，删帖，改密码，发邮件、银行转账等）。
		3）防御方法：
			（1）、验证码
			（2）、token令牌,（服务器端生成token,赋值到前端隐藏表单，然后提交表单token与服务器token比对）
	3、sql注入
	
 		1）方式
			（1）单引号、or
			（2）union
	 		 (3)/*（注释符），如用户名与密码登录时把密码注释掉，直接通过用户名后面加/*登录，（拼接的sql语句如：username = 'test' /* and password）
 		2）解决方式
			（1）在php.ini文件中把magic_quotes_gpc设为on （单引号被加入\转义）
	 		 (2)PDO （php data object） 预处理，sql语句变量用？代替，后面处理的时候再传入真实数据 （如：username=? and pwd=?,然后pdo执行excute([$username,$pwd])方法）
			（3）addslashes过滤
		3）危害：
			（1）暴露库，暴露表
			（2）传参的数据里面写sql，执行增删改查操作数据库给数据库带来损失

八、网站性能

	1、网站高并发（高并发读写）
		1）高并发读（查询）
			（1）1、负载均衡。2、建立主从数据库，分库分表。3、缓存。4、优化sql语句
		2）高并发写入（添加或更新）
			（1）如秒杀时库存超卖解决方案：执行事务时，先更新（减少）库存，然后去查询库存，得出结果并在事务里判断库存是否大于0,如果不大于，则抛出错误提示“库存不足”并回滚，否则就commit。
			（2）实际应用中，肯定不能如此高频率的去读写数据库，会严重造成性能问题的，直接写入会导致数据库压力太大挂掉。利用缓存。将需要秒杀的商品放入缓存中，并使用锁来处理其并发情况。当接到用户秒杀提交订单的情况下，先将商品数量递减（加锁）后再进行其他方面的处理，处理失败再将数据递增1（加锁），否则表示交易成功。当商品数量递减到0时，表示商品秒杀完毕，拒绝其他用户的请求。

	2、网站访问慢解决方案：
            通过php-fpm和mysql的cpu占用可以看出来是哪个导致的，如果php占用高则查看php的timeout和max_child优化php配置，如果mysql占用高，则查看my.cnf配置调优，优化之后，则查看慢查询日志，找出查询时间长的sql加以优化，另外带宽和服务器的软硬件配置，和程序逻辑，还有是否被攻击也是需要考虑的要素。


	3、秒杀、团购
		1）秒杀库存超卖解决方案：
			（1）“多线程”转成“单线程”（redis是单线程），依次排队，用redis中的队列（入队与出队）来操作，往redis中存入（lpush） 10个数到列表中，抢购开始后，每来一个用户就减去（lpop）一个数，当列表为空时，表示已经抢光了。因为列表的pop操作是原子的，即使有很多用户同时到达，也是依次执行的。
		2)原子性：就是执行这个指令时,不容许打断，依次执行，redis具有原子性
	4、千万级数据如何分页？
		1）思路：先查询出id，再根据id去查。如：SELECT * FROM product a JOIN (select id from product limit 866613, 20) b ON a.ID = b.id



九、websocket、workerman、swoole
	1、websocket的工作机制：
		1）客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求（http协议升级为websocket协议），服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了
	2、websocket与http区别
		1）websocket是HTML5中的协议，支持持久连接；而Http协议不支持持久连接。
		2）WebSocket是一种双向通信协议。在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，就像Socket一样；http只能客户端主动发送数据，服务端不能主动发数据
	3、websocket与socket区别
		1）WebSocket是应用层协议，Socket是传输控制层协议
	4、websocket与socket.io区别
		1)socket.io封装了websocket，同时包含了其它的连接方式，比如Ajax轮询，原因在于不是所有的浏览器都支持websocket。
		2）通过socket.io的封装，你不用关心里面用了什么连接方式。你在任何浏览器里都可以使用socket.io来建立异步的连接。socket.io包含了服务端和客户端的库，如果在浏览器中使用了socket.io的js，服务端也必须同样适用
	5、workerman：是一个PHP socket多进程服务器框架，具有PHP进程管理以及socket通信的模块，所以不依赖php-fpm、nginx或者apache等这些容器便可以独立运行。
	6、workerman与swoole区别
		1）都是php socket 服务器框架，workerman纯php写的，swoole是c编写的php扩展
		2) 因为swoole是基于c编写的,所以swoole速度更快,但bug多，workerman更稳定
