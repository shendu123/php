1、设计模式：http://www.php.cn/course/755.html（php中文网视频教程）。https://www.awaimai.com/patterns/observer(歪麦博客)。
	1）单例模式：允许创建一个而且只能创建一个对象的类
		（1）特点：
			一、3私1公：1个私有静态属性，1个私有构造方法，1个私有克隆方法，1个公共静态方法。
		（2）使用场景：
			一、配置类、Session类、Database类、Cache类、File类
		（3）作用：
			一、避免多次实例化带来的服务器内存开销
			二、例：在PHP的大多数应用中都会存在大量的数据库操作，如果不用单例模式，那每次都要new操作，但是每次new都会消耗大量的系统资源和内存资源
				而且每次打开和关闭数据库都是对数据库的一种极大考验和浪费。所以单例模式经常用在数据库操作类中				
		（4）优、缺点：
			一、优点：减少服务器内存开销
			二、缺点：php中的变量是页面级的，无法常驻内存，程序执行完后会被回收;
			三、彻底认清PHP单例模式的本质：https://www.cnblogs.com/in-loading/archive/2011/09/20/2182949.html

	2）工厂模式：就是负责生成其他对象的类或方法,而不是在代码中直接new。http://blog.csdn.net/hel12he/article/details/51703472
                （1）特点：定义一个创建对象的接口，让子类决定哪个类实例化。https://www.cnblogs.com/xuan-yan/p/7073800.html
                （2）使用场景：数据库驱动类（如：mysql、oracle）、支付类(如：微信支付、支付宝支付）
                （3）作用：拿支付举例 
                    一、例：写一个Pay类接口，里面写一个抽象pay方法，新建一个WxPay类与AliPay类，实现（implements）Pay接口，并实现Pay方法，里面封装自己的支付逻辑
                           ，另建一个PayFactory类,里面写一个静态的instance方法，对传进来的支付类型进行实例化,再写一个处理客户端请求的类orderPay，在orderPay类的方法里
                           调用PayFactory::instance（$type）->pay($data);
                （4）优、缺点：
                    一、优点：降低代码耦合，代码复用，避免在原来代码的基础上修改出错
                （5）简单工厂模式（静态工厂）：http://www.cnblogs.com/lovecucu/p/6069943.html
一、缺点：添加新的支付类型时要修改原来的代码，违背面向对象开闭原则（修改是封闭的，扩展是开放的），因为修改原来接口代码容易出错，不利于扩展，如果是工厂模式，只要新增一个支付类继承Pay类就就可以。
                （6）工厂模式：.http://blog.csdn.net/u010412301/article/details/54925217    
        3）观察者模式：就是观察者向主题注册，注册完之后，主题再通知观察者做出相应的操作。比如thinkphp5中的钩子技术（hook::add就是注册，hook::listen调用注册的接口）
                （1）特点：http://www.cnblogs.com/DeanChopper/p/4830134.html
                （2）使用场景：把用户对后台的操作记录写入日志                
	4）适配器模式：
		（1）特点：http://www.cnblogs.com/DeanChopper/p/4770572.html
		（2）使用场景：当你的实现和需要的接口，都不能修改的时候。如：你需要给甲方已有的系统做标准的兼容，标准不可修改，甲方的系统也不可修改，
                              这个时候你就需要适配器的设计模式了
		（3）作用：即根据客户端需要，将某个类的接口转换成特定样式的接口，以解决类之间的兼容问题
			一、例：假设Goods.php类里面有一个GoodsData方法,返回的是序列化（serialize）后的数据，现在java需要商品数据，但是java无法解析php序列化后的数据（不兼容），
				解决办法就是：建一个adapterGoods.php类继承Goods类，重写GoodsData方法，并且调用父类方法获取数据，对它反序列化unserialize（parent::GoodsData()）,
				然后转化为json(就是json_encode）返回，java就可以解析了(java可以解析json数据)
		（4）优点：低耦合，解决兼容问题
        5)装饰者模式 
                (1)https://www.cnblogs.com/yujon/p/5535324.html
2、面向对象知识点：
1）final：方法前加final，则方法不能被覆盖（重写），类前加final，则类不能被继承
2）面向对象三大特性：继承、封装、多态https://www.cnblogs.com/adaia/p/6986576.html
（1）封装：通过访问修饰符，将类中不需要外部访问的属性和方法进行私有化处理，来实现访问控制。https://www.cnblogs.com/wk1102/p/6986483.html?utm_source=itdadao&utm_medium=referral
（2）多态：同一个类的不同子类表现出不同的形态，就是有不同的属性与方法（如猫与老虎都属于动物，猫可以爬树，老虎吃人）https://www.cnblogs.com/tecs27/archive/2012/03/13/2394028.html
（3）构造函数继承问题
                		一、如果父类有构造函数，而且子类没有构造函数，那么在子类实例化时确实会执行父类构造函数
                		二、如果子类也有构造函数，那么当子类实例化时，不论父类是否有构造函数，都会执行子类自己的构造函数,不会继承父类构造函数。如果想要继承（想用父类构造函数里的方法或属性），则调用parent::__construct();
3）接口和抽象类：
			（1）抽象类通过关键字abstract 来声明，不能被实例化，只能作为其他类的父类来使用，抽象类中至少要包含一个抽象方法，抽象方法没有方法体，该方法天生就是要被子类重写的。
			（2）接口通过 interface 关键字来声明，接口中的方法也是没有方法体。接口中的方法也天生就是要被子类实现的，少一个都不行。
			（3）两者区别：
				一、接口能实现多继承，子类继承抽象类使用 extends，子类实现接口使用 implements
				二、抽象类和接口的区别在于使用动机。使用抽象类是为了代码的复用，而使用接口的动机是为了实现多态性
			（4）应用场景：
				一、抽象类：当多个同类的类要设计一个上层，通常设计为抽象类。（如：交通工具作为抽象类，飞机、汽车可以作为子类，飞机汽车都属于交通工具）
				二、接口：当多个异构的类要设计一个上层，通常设计为接口。（如：comparable接口，它只是说，实现这个接口的类必须要可以进行比较，这是一条规则。如果Car这个类实现了comparable，只是说，我们的Car中有一个方法可以对两个Car的实例进行比较，可能是比哪辆车更贵，也可能比哪辆车更大，这都无所谓，但我们不能说“汽车是一种特殊的可以比较”）。
			（5）注意点：
				一、接口是核心，其定义了要做的事情，包含了许多的方法，但没有定义这些方法应该如何做。 
				二、如果许多类实现了某个接口，那么每个都要用代码实现那些方法 
				三、如果某一些类的实现有共通之处，则可以抽象出来一个抽象类，让抽象类实现接口的公用的代码，而那些个性化的方法则由各个子类去实现。
4）PHP中private和public还有protected的区别
			（1）public （特点：公有）表示全局，类内部外部都可以访问；
			（2）protected: （特点：继承）受保护类型，用于本类和继承类（父、子类）调用。
			（3）private: （特点：私有）私有类型，只有在本类中使用。



