一、session与cookie
   
   1、session
	1）session 跨子域问题总结：
		（1）在php页面的最开始（要在任何输出之前，并且在session_start()之前）的地方进行以下设置  ini_set('session.cookie_domain', '.mydomain.com');
		（2）在php.ini里设置  session.cookie_domain = .mydomain.com
     		
     	2)、关于sessionid（session原理）：
		（1）如果网站开启了session（就是session_start()），第一次访问网站时服务端会返回一个sessionid给客户端保存在cookie中，详见http响应头（Response Headers）
  Set-Cookie:PHPSESSID=7qmhgolhumah9ce0j3m7b4lus4，第二次访问时，客户端带着cookie中的sessionid去请求服务器，详见http请求头（Request Headers）Cookie:PHPSESSID=7qmhgolhumah9ce0j3m7b4lus4，如果第三访问时你删掉sessionid对应的文件，服务器会根据请求头中的sessionid重新生成该文件,清除session时（session_destroy），会清空sessionid对应文件中的内容！session_id()是怎么产生的？是session_start()时产生的
		（2）如果关闭cookie，session_id可以通过url方式传递
	3）session存储方式：session.save_handler = files（默认为文件存储），也可以设置存储方式为内存（如redis,memcached）、数据库等。
	4）session存储路径：默认以文件的形式存储于服务器系统临时目录下(C盘)，session.save_path = "/tmp"，也可以自行指定目录。session.save_path = "N;MODE;/path"（N 表示多级目录，值为数字。MODE 表示创建的 Session 文件权限。/path 表示 Session 存储路径。）
	5）session文件的命名规则是：“sess_PHPSESSID值“。
	6）为什么删除一个session文件，之后生成一个session文件，新的文件名字还是与原来一样？因为sessionid存储在cookie里的，文件是通过sessionid来命名的
	7）session.auto_start = 0 如果设置为1，则不用在每个文件里写session_start(); session自动start 
	8）session_start()做了什么？
		（1）如果没有session文件，则生成sessionid，创建session文件
		（2）发送一个名称为PHPSESSID的头部cookie到浏览器，（解释了在调用session_start()之前不能有任何输出。有输出就会报错，因为头部信息必须在内容之前发送才行）
	9）sessionid存储方式
		（1）session.use_cookies = 1 sessionid在客户端采用的存储方式，置1代表使用cookie记录客户端的sessionid
		（2）session.use_trans_sid = 0 如果置1，则代表允许sessionid通过url参数传递，建议设置成0
	10）session.cookie_lifetime = 0 保存sessionid的cookie文件的生命周期，如置0，代表会话结束，则sessionid就自动消失，就是因为这个所以Session不能永久使用，常见的强行关闭浏览器，就会丢失上一次的sessionid；
	11）session生命周期：session.gc_maxlifetime：这个是Session数据在服务器端储存的时间，如果超过这个时间，那么Session数据就自动删除！
	12）session.name = PHPSESSID：这个就是SessionID储存的变量名称，可能是Cookie，也可能是Query_String来传递，默认值是“PHPSESSID”；

   2、cookie
	1) 原理：
		（1）当你访问一个网站的时候，服务器响应头会返回一个set-cookie信息（比如说用户名，id等）让浏览器保存到硬盘上，等你下次访问的时候带上这个cookie文件，服务器会首先寻找这个文件然后读取你的相关信息，这样可以让你在不输入用户名密码的情况下直接登陆网站,cookie就是服务器暂存放在你计算机上的一笔资料，好让服务器用来辨认你的计算机	
	2）用途：
		（1）记住用户名密码
	3）跨域：P3P
   3、session与cookie优缺点：
	1）session缺点：
		（1）在客户端是以cookie方式保存的，禁用cookie就没用了（url传递sessionid不安全）
	2）cookie缺点：
		（1）.客户端大小受限制，大多数浏览器对 Cookie 的大小有 4096 字节的限制
		（2）不安全	
   4、session与cookie区别：
	1）Cookie机制采用的是在客户端(浏览器)保持状态的方案，而session机制采用的是在服务器端保持状态的方案	
	




二、mysql知识点整理
   1、mysql分表分区
	1)分表：
		（1）一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件，一个.MYD数据文件，.MYI索引文件，.frm表结构文件。 
		（2）可以利用merge存储引擎，总表他不是一张表，没有数据，数据都放在分表里面，可以把总表理解成一个外壳，或者是联接池。 
		（3）分表查询与添加：
			一、查询：可以用union关联各分表查询。
			二、添加：可以用hash算法得出添加到哪个分表（参考一致性hash）。或者专门建一张表，用来存放所有用户ID，也就是说当有新数据插入时，先在这张表中产生一条记录，这条记录的主键就作为新用户ID，然后再根据这个用户ID来决定这个用户的注册数据插入到哪一张分表中。
		 (4)优点：分表后，单表的并发能力提高了，磁盘I/O性能也提高了。并发能力为什么提高了呢，因为查寻一次所花的时间变短了，如果出现高并发的话，总表可以根据不同的查询，将并发压力分到不同的小表里面。磁盘I/O性能怎么搞高了呢，本来一个非常大的.MYD文件现在也分摊到各个小表的.MYD中去了。 
		（5）分表方法：取模（%）（如：先建10张连续编号的表，然后根据id对编号取模落到哪张表上，比如 1%10在第一张表，2%10在第二张表....11%10在第一张表）
	2）分区：
		（1）把一张表的数据分成N多个区块，这些区块可以在同一个磁盘上，也可以在不同的磁盘上，但他还是一张表
		（2）RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区。（如：id为1-5的行在分区1中，id为6-10的行在分区2中），属于范围分区
		     LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。（离散值就是不连续，如：id为1、2、5的行在分区1中，id为3、6、8的行在分区2中），属于范围分区
		     HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。分为常规分区与线性分区。
			一、常规分区：就是取模（%）运算。根据余数插入到指定的分区
			二、线性分区：就是一致性hash分区
	             KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值
		（4）应用场景：访问量不大，但是表数据很多的表，我们可以采取分区的方式等。	
		（5）优点：
			一：分区可以分在多个磁盘，存储更大一点
			二：IO吞吐量更大（IO吞吐量顾名思义即单位时间内成功读写数据的数量）
		（6）缺点：
			一：分区键设计不太灵活，如果不走分区键，很容易出现全表锁
			二：不支持外键、不支持全文索引 、某些函数的限制（如：DAY（）、YEAR()）  	
				

   2、mysql优化
	1）索引：
		（1）、按存储结构划分：B-tree索引、hash索引（缺点：一、Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。二、哈希索引数据并不是按照索引列的值顺序存储的，所以也就无法用于排序。）
		（2）、索引类型（以下都是针对B-tree索引）：
			一、普通索引: index 仅仅是加快查询速度.
			二、唯一索引: unique index 行上的值不能重复
			三、主键索引: primary key 不能重复.主键必唯一,但是唯一索引不一定是主键.一张表上,只能有一个主键, 但是可以用一个或多个唯一索引.
			四、全文索引: fulltext index（上述3种索引,都是针对列的值发挥作用,但全文索引,可以针对一篇文章中的某个单词），
			　　关于全文索引的用法：Match (全文索引名) against ('keyword');
			　　在mysql的默认情况下, 对于中文意义不大.因为英文有空格,标点符号来拆成单词,进而对单词进行索引.而对于中文,没有空格来隔开单词,mysql无法识别每个中文词
			五、组合索引(多列进行索引，也叫联合索引，或复合索引)：create index myind on 表名 (列1,列2);最左原则			
		（3）、基本操作
			一、创建索引：create  index 索引名 on 表名 (列名...) 或  alter table 表名 add index 索引名 (列名...)
			二、删除索引：drop index 索引名 on 表名              或  alter table 表名 drop index index_name;
			三、显示索引：show index(es) from 表名               或  show keys from 表名 
		（4）、用到索引的情况：
			一、对于创建的多列索引，只要查询条件使用了最左边的列，索引一般就会被使用（最左原则）
			二、对于使用like的查询，查询如果是  ‘%aaa’ 不会使用到索引，‘aaa%’ 会使用到索引。
		（5）、下列情况将不使用索引：
			一、如果条件中有or，即使其中有条件带索引也不会使用。
			二、对于多列索引，不是使用的第一部分，则不会使用索引。
			三、like查询是以%开头
		（6）、在什么列上添加索引比较合适
			一、在经常查询的列上加索引.
			二、用于JOIN, WHERE判断和ORDER BY排序的字段
		       什么情况不适合索引？
			一、列的数据，内容就只有少数几个值,不太适合加索引（比如：status）
			二、内容频繁变化，不适合加索引（因为更新字段数据时也要更新索引）					
		（7）索引缺点：降低了增删改的速度（因为索引也要占空间，插入、修改数据的时候也会修改索引）
		（8）索引常用操作：
			一、查看索引：show index from tablename;
			二、分析索引（explain）：explain select * from a where a_id > 1 \G       （\G表示纵向显示信息）
		（9）聚簇索引与聚簇索引
			一、聚簇索引也叫簇类索引，是一种对磁盘上实际数据重新组织以按指定的一个或多个列的值排序
			二、区别：数据记录的排列顺序和索引的排列顺序是否一致来区分,聚簇索引排序一致，非聚簇索引不一致
			三、在对聚集索引列查询时，聚集索引的速度要比非聚集索引速度快。
		（10）覆盖索引
			一、定义：从索引中直接获取查询结果（比普通索引速度更快），不用回表查询
			二、触发条件：当要查询的列包含在索引列中（如：假设name列有建立索引，则select name from user会触发覆盖索引）
	2）sql语句优化
		（1）避免全表查询
		（2）不要在sql语句中使用mysql函数，因为这将导致引擎放弃使用索引而进行全表扫描
		（3）不要在sql语句中进行数值型字段计算。如：select * from goods where price/5<10;
		（4）使用连接（JOIN）来代替子查询(Sub-Queries)
	3）表设计优化：
		（1）核心常用字段放一张表（如：商品主表），不常用字段放另外一张表（如：商品详情表、商品图片表），两张表进行关联
		（2）合理选择字段类型（能用tinyint就不要用int）,因为大的字段浪费内存，影响速度
		（3）尽量避免用NULL: NULL不利于索引,null用索引比非null用索引占据更大磁盘空间.	
		
	4）清除表空间碎片  （optimize table 表名）
		（1）碎片产生的原因
			一、表的存储会出现碎片化，每当删除了一行内容，该段空间就会变为空白、被留空，而在一段时间内的大量删除操作，会使这种留空的空间变得比存储列表内容所使用的空间更大；
			二、当执行插入操作时，MySQL会尝试使用空白空间，但如果某个空白空间一直没有被大小合适的数据占用，仍然无法将其彻底占用，就形成了碎片；

	
			
   3、mysql存储引擎、存储过程、视图、触发器	
	1)存储引擎：
		(1)MyISAM与InnoDB区别：
			一、MyISAM：每个MyISAM在磁盘上存储成三个文件。.frm（表结构frame）.MYD (表数据MYData) .MYI (表索引MYIndex)。
			    InnoDB：所有的表都保存在同一个文件*.frm中,数据存放到ibdata1，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。
			二、MyISAM不提供事务支持。InnoDB支持事务			    
			三：MyISAM支持表级锁、InnoDB支持行级锁
			四：MyISAM支持 FULLTEXT类型的全文索引，InnoDB不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。
			五：MyISAM利于读（select）,	InnoDB利于写（insert、update、delete）
			六：MyISAM不支持外键，	InnoDB支持外键（外键：一个表的外键是另一个表的主键）
			七：存储空间：MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。
				      InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引
		（2）MEMORY存储引擎：数据存储在内存中，读取数据速度快，但是断电数据会丢失。默认是hash索引。
		（3）merge存储引擎：简单管理动态日志表（比如：把不同的月份放在不同的表上）、分表	
	2)存储过程：
		(1)存储过程概念类似于函数,就是把一段代码封装起来,当要执行这一段代码的时候,可以通过调用该存储过程来实现.在封装的语句体里面,可以用if/else, case,while等控制结构.可以进行sql编程.
	       （2）调用存储过程：Call 存储过程名字();
		    查看现有的存储过程：Show procedure status
		    删除存储过程：Drop procedure 存储过程的名字	
	       （3）在mysql中,存储过程和函数的区别：
			一：标识符不同。函数的标识符为FUNCTION，过程为：PROCEDURE。
			二：调用方式不同
			三：存储过程没有返回值.
	3）视图：
	        （1）视图是查询结果构成的一张虚拟表	
		（2）视图基本操作
			一：视图的创建语法:Create view 视图名 as  select 语句;
			二：视图调用：因为虚拟表也是表，所以与普通表调用方法一样，如：select * from 视图名
			二：视图修改：Alter view 视图名 as select  语句;
			三：视图删除：Drop view 视图名
		（3）视图作用：
			一：可以简化查询，把复杂的sql语句封装起来添加到视图，用时直接查询视图就要以了
			二：安全，可以进行权限控制，把表的权限封闭,但是开放相应的视图权限,视图里只开放部分数据
			三：可以合并分离的数据，把多个查询语句用union关联形成一张视图Create view news as  select * from n1 union select  * from n2 union....
	4）触发器：
		（1）概念: 监视某种情况并触发某种操作.	比如：完成下单就要触发减少库存的sql操作
		（2）触发器里after 和before的区别：After 是先完成数据的增,删,改再触发,Before是先完成触发,再增删改	
		    		
			
   4、mysql主从复制、读写分离、集群
	1）主从复制
	 	（1）主从复制原理：当主库有更新时，会将更新语句写入binlog日志文件中，此时主库会创建logdump线程通知slave有数据更新，并将binlog名称和当前更新的位置同时传给slave，然后slave进行同步
		（2）主从同步延迟：当主库并发比较高，超过slave一个sql线程所能承受的范围，就会出现从服务器同步主服务器延迟，解决办法：添加redis或memcache缓存降低从服务器的读压力、关闭从服务的binlog日志、配置更好的从服务器
		（3）主从复制作用：读写分离减轻服务器压力、数据备份
		
	2）读写分离：主从复制的目的就是为了读写分离，用到mysql-proxy调度服务器（mysql中间件，相当于客户端与服务器之间的代理层）
	3）集群（Cluster）：高可用、高性能的服务器架构方案
		（1）由三种类型的服务组成（管理节点、sql节点、数据节点）
			一、NDB Management Server：管理服务器主要用于管理cluster中的其他类型节点（Data Node和SQL Node），通过它可以配置节点信息，启动和停止节点
			二、SQL Node：在MySQL Cluster中，一个SQL Node就是一个使用NDB引擎的mysql server进程，作为数据库使用。被数据节点访问
			三、Data Node：用于存储集群数据；系统会尽量将数据放在内存中。保存进数据节点的数据都会自动复制并存储到其他数据节点。
		（2）需要注意的是，创建表的时候必须选择表的引擎为NDBCLUSTER，否则表不会进行同步
		（3）集群最少要求有3台服务器.不过我们建议最好是4台;有2台分别运行管理节点和SQL节点,另外2台作为数据节点.采取2台数据节点的目的是提高数据的冗余度,管理节点放在一个独立的主机上是为了能够保证在万一有一台数据节点失败的情况下提供仲裁服务.
		（4）主从复制无法做到高可用，因为如果主挂了，从只能提供读，不能提供写，集群可以高可用，一台服务器宕机了，还有多台可以提供服务
	4）集群与主从复制（replication）区别：集群时数据是共享的，主从复制时数据是完全独立在服务器上的				   		
	   集群与分布式区别：集群是多个服务器完成同一个业务，某个服务器宕机，业务不受影响。
			     分布式是一个业务分布在多个服务器上，只要其中的一个服务器出故障，业务就会受到影响
	5）高可用（HA   High Available）特点：
		（1）软件故障监测与排除
		（2）备份和数据保护
		（3）实现错误隔离以及主、备份服务器间的服务切换，负载均衡
	6）服务器冗余技术
		（1）重复配置系统的一些部件,当系统发生故障时,冗余配置的部件介入并承担故障部件的工作,由此减少系统的故障时间。	


   5、其它
	1）mysqld意思是mysql daemon，在后台运行的服务器，监听3306端口，mysql是一个客户端软件，可以对任何主机的mysql服务（即后台运行的mysqld）发起连接。		
	2）mysql导入导出sql文件：
		(1）导出：mysqldump -u 用户名 -p 数据库名 > 导出的文件名
                          mysqldump -u dbuser -p dbname > dbname.sql
		(2）导入：mysql>     source d:/dbname.sql
	3）SQL 分类：
		（1）DDL（Data Definition Languages）语句：数据定义语言。常用的语句关键字主要包括 create、drop、alter等。
		（2）DML（Data Manipulation Language）语句：数据操纵语言。常用的语句关键字主要包括 insert、delete、udpate 和select 等。(增添改查）
		 (3) DCL（Data Control Language）语句：数据控制语句。定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 grant、revoke 等。	
	4）授权（grant）与撤消权限（revoke）
		（1）grant语法： grant 权限 on 数据库对象 to 用户  (如果用户不存在，则 grant 权限 on 数据库对象 to 用户 identified by 密码;)
			一、grant add,update on testdb.* to common_user@'%'，给用户授予添加、修改的权限，testdb.*表示testdb下所有的表，%表示所有ip
			二、grant all on *.* to dba@'localhost'  identified by '123456'添加用户dba并授予mysql中所有数据库的权限（只能在localhost下）
		（2）查看权限：show grants;  查看其他 MySQL 用户权限：show grants for dba@localhost;
		（3）revoke语法：revoke 权限 on 数据库对象 from 用户
			一、revoke语法与grant相似,grant是to，revoke是from
		（4）注意：grant, revoke 用户权限后，该用户只有重新连接 MySQL 数据库（或flush privileges），权限才能生效。
		（5）flush privileges刷新权限
			一、本质上的作用是将当前user和privilige表中的用户信息/权限设置从mysql库(MySQL数据库的内置库)中提取到内存里。
			二、两种情况下需要刷新权限：1、授权或取消授权。2、修改mysql用户密码（如：update user set Password = PASSWORD where User ='root'）。
		（6）mysql授权表：共有5个表：user、db、host、tables_priv和columns_priv。
			一、user表：用户表，user表启用的任何权限均是全局权限，并适用于所有数据库。例如，如果你启用了DELETE权限，在这里列出的用户可以从任何表中删除记录
			二、db表：db表列出数据库，而用户有权限访问它们。在这里指定的权限适用于一个数据库中的所有表。
			三、host表：host表与db表结合使用在一个较好层次上控制特定主机对数据库的访问权限，这个表不受GRANT和REVOKE语句的影响
			四、tables_priv表：tables_priv表指定表级权限，在这里指定的一个权限适用于一个表的所有列。
			五、columns_priv表：columns_priv表指定列级权限。这里指定的权限适用于一个表的特定列。
		（7）mysql_install_db脚本初始化权限表
	5）mysql启动方式：
		（1）mysql_safe：是shell脚本启动，检测mysqld进程是否启动。如果mysqld没启动或挂了，会尝试重启mysqld
		（2）mysql.server：也是shell脚本启动，其实也是调用了mysql_safe，调用顺序：mysql.server->mysql_safe->mysqld
		（3）service mysql start：  复制mysql进程到/etc/init.d/mysql  	直接调用mysqld(进程启动)
		（4）到mysql目录下直接启动mysql进程
	6）注意：无论什么服务启动，只要是以service方式启动的，都是把启动进程复制到etc/init.d/目录）
	7）Mysql有两种连接方式：（http://blog.csdn.net/u011249920/article/details/52100761）
		（1）TCP/IP
			一、127.0.0.1则是使用tcp来连接    mysql -h 127.0.0.1 -u root -p
		（2）socket
			一、localhost默认是使用sock连接,
	8)mysql.socket：  
		（1）作用：socket方式连接mysql,服务器与本地客户端进行通信的Unix套接字文件，如果文件被删，则localhost下的用户无法连接到mysql服务器
		（2）mysql启动时会产生mysql.socket文件，如果文件被删，重启时又会生成该文件，如果没有，则用tcp连接mysql
	9）脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
	10）悲观锁与乐观锁
		（1）悲观锁：锁如其名，他对世界是悲观的，他认为别人访问正在改变的数据的概率是很高的，所以从数据开始更改时就将数据锁住，直到更改完成才释放。
		（2）乐观锁：他对世界比较乐观，认为别人访问正在改变的数据的概率是很低的，所以直到修改完成准备提交所做的的修改到数据库的时候才会将数据锁住。完成更改后释放。基于数据版本（ Version ）记录机制实现。更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。
		（3）悲观锁与乐观锁缺点：
			一、悲观锁会造成访问数据库时间较长，性能开销大，并发性不好，特别是长事务。
			二、乐观锁可能会造成脏数据被更新到数据库（脏读）
		（4）适用场景：
			一、悲观锁适用于高并发写入，写比较多的情况
			二、乐观锁适用于写比较少，读比较多的情况，好处是省去锁的开销，加大了整个系统的吞吐量。坏处是如果写比较多，可能会造成脏读
	11）show
		（1）show global status与show status 区别：
			一、有global是你本次MYSQL服务开启（或重置）到现在总请求数。	
			二、没global是你本次连接的请求数,flush status重置
		（2）show variables与show satus区别
			一、show variables查看的是系统变量（系统参数），是静态，可以通过set命令，或者修改mysql配置文件调整。（如：开启慢查询日志）
			二、show status 查看的是系统状态。是动态生成，无法调整。						
	12）慢查询：
		（1）开启慢查询（my.cnf中添加以下三句）
			一、slow_query_log = ON（on表示开启，off未开启）
			二、slow_query_log_file = /usr/local/mysql/data/slow.log（慢查询日志路径）
			三、long_query_time=2	（2表示查询超过两秒才记录.）
	13）mysql临时表：存储在内存的表，mysql断开就销毁。
		（1）应用场景：	当一个数据库存在着大量的数据的时候，我们想要获取到这个数据集合的一个子集，那么我们就可以使用临时表来保存我们想要的数据。。然后对临时表进行操作就可以了...使用临时表必然是有原因的。使用临时表会加快数据库的查询性能！（与视图区别：视图是虚拟表）	
		（2）创建：CREATE TEMPORARY TABLE......（与创建普通表一样，就是多了个temporary）	

三、NoSql数据库
	1、mongodb
		1）mongodb与mysql区别：
			（1）MySQL是传统的关系型数据库，MongoDB则是非关系型数据库，也叫文档型数据库，是一种NoSQL的数据库。json风格，key，value方式存储。由于Mysql的读写速度会有一点瓶颈，于是我们就想到了最近发展很强势的Nosql，
			（2）关系型数据库：数据库的每个表都可以有关联。一对多，多对多，一对一的关系。还有就是二维的，行，列。	
		2） mongodb与mysql相比优缺点
			（1）优点：1、访问速度更快.2、文档结构的存储方式，能够更方便获取数据3、支持大容量的存储	
			（2）缺点：1、不支付事务




四、redis、memcache知识点整理

	1、redis
		1）基本使用
			（1）redis不仅是缓存服务器，还是存储服务器，因为其具有持久化的特点
			（1）一个redis进程,打开了不止一个数据库, 默认打开16个数据库,从0到15编号
			（2）事务：与mysql事务不一样，没有回滚，只有discard（取消），如果前两句执行成功，第三句失败，前两名造成的影响还存在
			（3）消息订阅：订阅端: Subscribe 频道名称。发布端: publish 频道名称 发布内容
			（4）持久化有两种方式：一、快照rdb（redis database）,把数据存入硬盘、二、日志 aof (append only file)
			（5）恢复时rdb和aof哪个恢复的快？：db快,因为其是数据的内存映射,直接载入到内存,而aof是命令,需要逐条执行	
			（6）aof重写是指什么?aof重写是指把内存中的数据,逆化成命令,写入到新的aof日志里。以解决 aof日志过大的问题.

		2）rdb与aof对比优缺点：
			（1）rdb优点：
				一、恢复数据快
				二、可以最大化redis的性能，父进程只需要fork出子进程，让子进程处理所有的读写保存工作，父进程无需IO操作
			（2）rdb缺点：如果服务器出故障，没有达到rdb配置时间的数据不能生成快照会丢失（达到时间了才会生成快照）
			（3）aof缺点：比较慢，访问压力大时IO会成为性能瓶颈，进而导致服务不可用	
		3）redis主从：
			（1）：缺陷:当主服务器挂了，因为从服务器只能读不能写，	所以还是不能提供服务
			（2）：解决办法：redis sentinel（redis哨兵，监控） 可以将从服务器升级为主服务器，或者用集群
			（3）：sentinel工作原理：Sentinel不断与master通信,获取master的slave信息，监听master与slave的状态，如果某slave失效,直接通知master去除该slave，如果master失效,是按照slave优先级(可配置), 选取1个slave做新的master
		4）redis集群
			（1）：	集群没有主从之分，这个宕机了另一个可以立即提供服务
		5) 基础知识
			（1）：Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。
			（2）：有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
			（2）list常用命令
				一、lpush：由列表头部添加字符串值（返回值：成功返回数组长度，失败false）
				二、rpush：由列表尾部添加字符串值（返回值：成功返回数组长度，失败false）
				三、lpop：返回和移除列表的第一个元素(返回值：成功返回第一个元素的值 ，失败返回false)
				四、llen：返回的列表的长度。
			（3）zset常用命令
				一、Zrangebyscore：通过分数返回有序集合指定区间内的成员（如：ZRANGEBYSCORE key min max）
				二、Zadd：向有序集合添加一个或多个成员，或者更新已存在成员的分数（如：ZADD key score1 member1 [score2 member2]）			 				三、zcard 返回存储在key对应的有序集合中的元素的个数 	（如：zcard key）

		   
	2、memcache
		1)基本使用
		     	（1）memcache依赖于libevent库，所以需要先安装libevent。
		     	（2）启动：/usr/local/bin/memcached  -m 256  -p 11211 -u root -d   -l 192.168.1.101 -c 50000 -t 8	-f 2
			  参数说明：
				（一）、-m 分配给该memcached的内存大小，以MB为单位。（默认：64MB）
				（二）、-p 监听的TCP端口(默认: 11211)
				（三）、-u 设定进程所属用户。（只有root用户可以使用这个参数）
				（四）、-d 作为守护进程来运行(守护进程：在后台运行不受终端控制的进程（如输入、输出等）)
				（五）、-l 监听的IP地址。（默认：INADDR_ANY，所有地址）
				（六）、-c 最大并发连接数。（默认：1024)
				（七）、-t 使用的线程数（默认：4）
				（八）、-f 不同slab class里面的chunk大小的增长倍率(增长因子)。（默认：1.25）
				 (八)、-vvv超详细信息（还打印内部状态的变化）
				（九）、-h 帮助信息
		      	（3）客户端连接工具：telnet
		      	（4）命令：add、replace（替换）、get、delete、set(相当于add与replace两者合用)、incr（增加)、decr(减少)、stats(统计)、flush_all(清空所有储存对象)
		      	（5）内存管理:
				（一）、内存碎片化：不断申请不断释放内存时形成的小内存片断无法利用造成的浪费
				（二）、slab allocator机制缓解内存碎片化：把内存划分成数个slab allocator仓库，各仓库再切分成不同的尺寸的小块（chunk）,需要存内容时，判断内容的大小，选择合理的仓库	
				（三）、固定大小的chunk造成的内存浪费怎么解决：在连接memcache时，通过-f参数，设置合理的增长因子（grow factor）来缓解
		      	（6）过期数据惰性删除：过期后并没有从内存中删除，	get获取数据的时候才从内存删除，好处：节省检测成本
		      	（7）lru删除机制：least recently used(最近最少使用)，有限的内存空间，最少使用的就被删除，旧数据被踢出		
		2）分布式集群算法：
		      	（1）取模(%)算法： 缺点：服务器增加或删除的时候命中率会受影响，down机厉害
		       	 (2) 一致性hash算法：
				一、首先求出所有memcached服务器（节点）的哈希值，并将其配置到0～2的32次方的圆（continuum）上。
				二、然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。
				三、然后从数据映射到的位置开始顺时针查找，如果两者哈希值非常接近，将数据保存到找到的第一个服务器上。如果超过2的32次方仍然找不到服务器，就会保存到第一台memcached服务器上。
			（3）hash值计算方法：printf("%u",crc32('hello'));主要是利用crc32函数来计算任意数的hash值，%u是unsigned（无符号）类型的数值，避免出现负数。	
		3）缓存雪崩
		      	（1）原因：一般是由某个缓存节点失效，导致其它节点的缓存命中率下降，缓存中缺失的数据去数据库查询，短时间内，造成数据库服务器崩溃
		      	（2）解决办法：根据不同节点设置不同的缓存失效时间，随机3到9小时的生命周期，把工作分担到不同的时间点上，最好是晚上更新缓存，因为晚上访问量小		
	3、memcache与redis区别
		1）memcache是多线程（利于并发），redis是单线程
		2）Redis存储的数据类型更多，不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储
		3）memcache把数据保存在内存中，如果断电，数据全没了；redis可以定期保存到磁盘（持久化）
		4) memcache 存储数据key的长度为250字符，缓存对象（也就是value）的大小为1MB