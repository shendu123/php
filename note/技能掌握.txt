一、session与cookie
   
   1、session	
     1)、关于sessionid：
			如果网站开启了session（就是session_start()），第一次访问网站时服务端会返回一个sessionid给客户端保存在cookie中，详见http响应头（Response Headers）
  Set-Cookie:PHPSESSID=7qmhgolhumah9ce0j3m7b4lus4，第二次访问时，客户端带着cookie中的sessionid去请求服务器，详见http请求头（Request Headers）Cookie:PHPSESSID=7qmhgolhumah9ce0j3m7b4lus4，如果第三访问时你删掉sessionid对应的文件，服务器会根据请求头中的sessionid重新生成该文件,清除session时（session_destroy），会清空sessionid对应文件中的内容！session_id()是怎么产生的？是session_start()时产生的




二、mysql知识点整理
   1、mysql分表分区
	1)分表：
		（1）一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件，一个.MYD数据文件，.MYI索引文件，.frm表结构文件。 
		（2）可以利用merge存储引擎，总表他不是一张表，没有数据，数据都放在分表里面，可以把总表理解成一个外壳，或者是联接池。 
		（3）查询：可以用union关联各分表查询。添加：可以用hash算法得出添加到哪个分表
		 (4)优点：分表后，单表的并发能力提高了，磁盘I/O性能也提高了。并发能力为什么提高了呢，因为查寻一次所花的时间变短了，如果出现高并发的话，总表可以根据不同的查询，将并发压力分到不同的小表里面。磁盘I/O性能怎么搞高了呢，本来一个非常大的.MYD文件现在也分摊到各个小表的.MYD中去了。 
	2）分区：
		（1）把一张表的数据分成N多个区块，这些区块可以在同一个磁盘上，也可以在不同的磁盘上，但他还是一张表
		（2）RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区。（如：id为1-5的行在分区1中，id为6-10的行在分区2中）
		     LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。（离散值就是不连续）
		     HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。
	             KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值
		（4）应用场景：访问量不大，但是表数据很多的表，我们可以采取分区的方式等。	
		（5）优点：
			一：分区可以分在多个磁盘，存储更大一点
			二：IO吞吐量更大（IO吞吐量顾名思义即单位时间内成功读写数据的数量）
		（6）缺点：
			一：分区键设计不太灵活，如果不走分区键，很容易出现全表锁
			二：不支持外键、不支持全文索引 、某些函数的限制（如：DAY（）、YEAR()）  	
				

   2、mysql优化
	1）索引：
		（1）、按存储结构划分：B-tree索引、hash索引（缺点：一、Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。二、哈希索引数据并不是按照索引列的值顺序存储的，所以也就无法用于排序。）
		（2）、索引类型（以下都是针对B-tree索引）：
			一、普通索引: index 仅仅是加快查询速度.
			二、唯一索引: unique index 行上的值不能重复
			三、主键索引: primary key 不能重复.主键必唯一,但是唯一索引不一定是主键.一张表上,只能有一个主键, 但是可以用一个或多个唯一索引.
			四、全文索引: fulltext index（上述3种索引,都是针对列的值发挥作用,但全文索引,可以针对一篇文章中的某个单词），
			　　关于全文索引的用法：Match (全文索引名) against ('keyword');
			　　在mysql的默认情况下, 对于中文意义不大.因为英文有空格,标点符号来拆成单词,进而对单词进行索引.而对于中文,没有空格来隔开单词,mysql无法识别每个中文词
			五、组合索引(多列进行索引)：create index myind on 表名 (列1,列2);最左原则			
		（3）、基本操作
			一、创建索引：create  index 索引名 on 表名 (列名...) 或  alter table 表名 add index 索引名 (列名...)
			二、删除索引：drop index 索引名 on 表名              或  alter table 表名 drop index index_name;
			三、显示索引：show index(es) from 表名               或  show keys from 表名 
		（4）、用到索引的情况：
			一、对于创建的多列索引，只要查询条件使用了最左边的列，索引一般就会被使用（最左原则）
			二、对于使用like的查询，查询如果是  ‘%aaa’ 不会使用到索引，‘aaa%’ 会使用到索引。
		（5）、下列情况将不使用索引：
			一、如果条件中有or，即使其中有条件带索引也不会使用。
			二、对于多列索引，不是使用的第一部分，则不会使用索引。
			三、like查询是以%开头
		（6）、在什么列上添加索引比较合适
			一、在经常查询的列上加索引.
			二、列的数据，内容就只有少数几个值,不太适合加索引（比如：status）
			三、内容频繁变化，不适合加索引（因为更新表时也要更新索引）	
		（7）：缺点：降低了增删改的速度.
			
   3、mysql存储引擎、存储过程、视图、触发器	
	1)存储引擎：
		(1)MyISAM与InnoDB区别：
			一、MyISAM：每个MyISAM在磁盘上存储成三个文件。.frm（表结构）.MYD (表数据MYData) .MYI (表索引MYIndex)。
			    InnoDB：所有的表都保存在同一个文件*.frm中,数据存放到ibdata1，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。
			二、MyISAM不提供事务支持。InnoDB支持事务			    
			三：MyISAM支持表级锁、InnoDB支持行级锁
			四：MyISAM支持 FULLTEXT类型的全文索引，InnoDB不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。
			五：MyISAM利于读（select）,	InnoDB利于写（insert、update、delete）
			六：MyISAM不支持外键，	InnoDB支持外键（外键：一个表的外键是另一个表的主键）
			七：存储空间：MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。
				      InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引
		（2）MEMORY存储引擎：数据存储在内存中，断电数据会丢失
		（3）merge存储引擎：简单管理动态日志表（比如：把不同的月份放在不同的表上）、分表	
	2)存储过程：
		(1)存储过程概念类似于函数,就是把一段代码封装起来,当要执行这一段代码的时候,可以通过调用该存储过程来实现.在封装的语句体里面,可以用if/else, case,while等控制结构.可以进行sql编程.
	       （2）调用存储过程：Call 存储过程名字();
		    查看现有的存储过程：Show procedure status
		    删除存储过程：Drop procedure 存储过程的名字	
	       （3）在mysql中,存储过程和函数的区别：
			一：标识符不同。函数的标识符为FUNCTION，过程为：PROCEDURE。
			二：调用方式不同
			三：存储过程没有返回值.
	3）视图：
	        （1）视图是查询结果构成的一张虚拟表	
		（2）视图基本操作
			一：视图的创建语法:Create view 视图名 as  select 语句;
			二：视图调用：因为虚拟表也是表，所以与普通表调用方法一样，如：select * from 视图名
			二：视图修改：Alter view 视图名 as select  语句;
			三：视图删除：Drop view 视图名
		（3）视图作用：
			一：可以简化查询，把复杂的sql语句封装起来添加到视图，用时直接查询视图就要以了
			二：安全，可以进行权限控制，把表的权限封闭,但是开放相应的视图权限,视图里只开放部分数据
			三：可以合并分离的数据，把多个查询语句用union关联形成一张视图Create view news as  select * from n1 union select  * from n2 union....
	4）触发器：
		（1）概念: 监视某种情况并触发某种操作.	比如：完成下单就要触发减少库存的sql操作
		（2）触发器里after 和before的区别：After 是先完成数据的增,删,改再触发,Before是先完成触发,再增删改	
		    		
			
   4、mysql主从复制、读写分离、集群
	1）主从复制
	 	（1）主从复制原理：当主库有更新时，会将更新语句写入binlog日志文件中，此时主库会创建logdump线程通知slave有数据更新，并将binlog名称和当前更新的位置同时传给slave，然后slave进行同步
		（2）主从同步延迟：当主库并发比较高，超过slave一个sql线程所能承受的范围，就会出现从服务器同步主服务器延迟，解决办法：添加redis或memcache缓存降低从服务器的读压力、关闭从服务的binlog日志、配置更好的从服务器
		（3）主从复制作用：读写分离减轻服务器压力、数据备份
		
	2）读写分离：主从复制的目的就是为了读写分离，用到mysql-proxy调度服务器
	3）集群：主从复制无法做到高可用，因为如果主挂了，从只能提供读，不能提供写，集群可以高可用，一台服务器宕机了，另一台完全可以提供服务
	4）集群与主从复制（replication）区别：集群时数据是共享的，主从复制时数据是完全独立在服务器上的				   		
	   集群与分布式区别：集群是多个服务器完成同一个业务，某个服务器宕机，业务不受影响。
			     分布式是一个业务分布在多个服务器上，只要其中的一个服务器出故障，业务就会受到影响	



三、redis、memcache知识点整理

		1、redis
		   1）基本使用
			（1）redis不仅是缓存服务器，还是存储服务器，因为其具有持久化的特点
			（1）一个redis进程,打开了不止一个数据库, 默认打开16个数据库,从0到15编号
			（2）事务：与mysql事务不一样，没有回滚，只有discard（取消），如果前两句执行成功，第三句失败，前两名造成的影响还存在
			（3）消息订阅：订阅端: Subscribe 频道名称。发布端: publish 频道名称 发布内容
			（4）持久化有两种方式：一、快照rdb（redis database）,把数据存入硬盘、二、日志 aof (append only file)
			（5）恢复时rdb和aof哪个恢复的快？：db快,因为其是数据的内存映射,直接载入到内存,而aof是命令,需要逐条执行	
			（6）aof重写是指什么?aof重写是指把内存中的数据,逆化成命令,写入到新的aof日志里。以解决 aof日志过大的问题.

		   2）rdb与aof对比优缺点：
			（1）rdb优点：
				一、恢复数据快
				二、可以最大化redis的性能，父进程只需要fork出子进程，让子进程处理所有的读写保存工作，父进程无需IO操作
			（2）rdb缺点：如果服务器出故障，没有达到rdb配置时间的数据不能生成快照会丢失（达到时间了才会生成快照）
			（3）aof缺点：比较慢，访问压力大时IO会成为性能瓶颈，进而导致服务不可用	
		   3）redis主从：
			（1）：缺陷:当主服务器挂了，因为从服务器只能读不能写，	所以还是不能提供服务
			（2）：解决办法：redis sentinel（redis哨兵，监控） 可以将从服务器升级为主服务器，或者用集群
		   4）redis集群
			（1）：	集群没有主从之分，这个宕机了另一个可以立即提供服务								 	

		   
		2、memcache
		   1)基本使用
		     （1）memcache依赖于libevent库，所以需要先安装libevent。
		     （2）启动：/usr/local/bin/memcached  -m 256  -p 11211 -u root -d   -l 192.168.1.101 -c 50000 -t 8	-f 2
			  参数说明：
				（一）、-m 分配给该memcached的内存大小，以MB为单位。（默认：64MB）
				（二）、-p 监听的TCP端口(默认: 11211)
				（三）、-u 设定进程所属用户。（只有root用户可以使用这个参数）
				（四）、-d 作为守护进程来运行(守护进程：在后台运行不受终端控制的进程（如输入、输出等）)
				（五）、-l 监听的IP地址。（默认：INADDR_ANY，所有地址）
				（六）、-c 最大并发连接数。（默认：1024)
				（七）、-t 使用的线程数（默认：4）
				（八）、-f 不同slab class里面的chunk大小的增长倍率(增长因子)。（默认：1.25）
				 (八)、-vvv超详细信息（还打印内部状态的变化）
				（九）、-h 帮助信息
		      （3）客户端连接工具：telnet
		      （4）命令：add、replace（替换）、get、delete、set(相当于add与replace两者合用)、incr（增加)、decr(减少)、stats(统计)、flush_all(清空所有储存对象)
		      （5）内存管理:
				（一）、内存碎片化：不断申请不断释放内存时形成的小内存片断无法利用造成的浪费
				（二）、slab allocator机制缓解内存碎片化：把内存划分成数个slab allocator仓库，各仓库再切分成不同的尺寸的小块（chunk）,需要存内容时，判断内容的大小，选择合理的仓库	
				（三）、固定大小的chunk造成的内存浪费怎么解决：在连接memcache时，通过-f参数，设置合理的增长因子（grow factor）来缓解
		      （6）过期数据惰性删除：过期后并没有从内存中删除，	get获取数据的时候才从内存删除，好处：节省检测成本
		      （7）lru删除机制：least recently used(最近最少使用)，有限的内存空间，最少使用的就被删除，旧数据被踢出		
		   2）分布式集群算法：
			（1）取模算法： 缺点：服务器增加或删除的时候命中率会受影响，down机厉害
			 (2) 一致性hash算法：服务器越多，命中率越高
		   3）缓存雪崩
			 （1）原因：一般是由某个缓存节点失效，导致其它节点的缓存命中率下降，缓存中缺失的数据去数据库查询，短时间内，造成数据库服务器崩溃
			 （2）解决办法：根据不同节点设置不同的缓存失效时间，随机3到9小时的生命周期，把工作分担到不同的时间点上，最好是晚上更新缓存，因为晚上访问量小		
		3、memcache与redis区别
		   1）memcache是多线程（利于并发），redis是单线程
		   2）Redis存储的数据类型更多，不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储
		   3）memcache把数据保存在内存中，如果断电，数据全没了；redis可以定期保存到磁盘（持久化）