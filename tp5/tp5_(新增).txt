1、行为（也就是钩子）
	1）定义：应用执行过程中的一个动作
	2）作用：有些行为的作用位置都是在应用执行前，有些行为都是在模板输出之后，我们把这些行为发生作用的位置称之为标签（位），当应用程序运行到这个标签的时候，就会被拦截下来，统一执行相关的行为
	3）例子：记录网站操作日志功能，hook::listen（module_init）先监听模块初始化，（在tags.php里配置相应的类'\\app\\common\\behavior\\WebLog'），在自己的业务里获取获取网站请求操作相关值并进行初始化赋值，当程序执行完，也就是数据初始化之后，数据处理(模板渲染)之前，有一个hook::listen（app_end）应用结束监听行为，可以对这个行为进行数据库插入操作。就完成了对网站的操作记录功能。（详见tpadmin操作日志模块）
	4）注册行为：
                （1）手动注册：hook:add()
                （2）自动注册：在配置文件tags.php中进行配置   
        5) 详细说明：http://blog.csdn.net/u013927110/article/details/47000379   
2、路由（域名邦定模块）
3、控制器
	1）分层控制器：
		（1）不在默认Controller目录，在指定的控制器目录。如：\think\Loader::controller('Blog', 'event');在event目录下的Blog控制器
5、反射  
	1)定义：
		（1）、https://www.cnblogs.com/KeenLeung/p/6041280.html
		（2）、PHP Reflection API详解:http://www.jb51.net/article/65897.htm
		（3）、它是指在PHP运行状态中，扩展分析PHP程序，导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取的信息以及动态调用对象的方法的功能称为反射API。
			PHP反射api由若干类组成，可帮助我们用来访问程序的元数据或者同相关的注释交互。借助反射我们可以获取诸如类实现了那些方法，创建一个类的实例（不同于用new创建），调用一个方法（也不同于常规调用），传递参数，动态调用类的静态方法
	2) 反射类
		（1）ReflectionClass类
			一、getConstructor方法：取得该类的构造函数信息
			二、newInstanceArgs方法：实例化该类
		（2）ReflectionMethod类		
			一、getNumberOfParameters方法：获取控制器构造函数参数个数或请求方法参数个数
			二、getParameters方法：获取控制器构造函数参数或请求方法参数（返回ReflectionParameter对象）
			三、invoke方法：调用该方法
			四、isPublic方法：测试该方法是否为public
			五、isStatic方法：测试该方法是否为static
		（3）ReflectionParameter类
			一、getName方法：取得参数名
			二、getClass方法：若该参数为对象，返回该对象的类名
	3）邦定参数、依赖注入

6、模型
	1）分层模型：
		（1）不在默认Model目录，在指定的模型目录。如：\think\Loader::model('User', 'logic');在logic目录下的User类
	
7、验证
	1）$rule instanceof \Closure判断规则函数是否为匿名函数
	2）内置函数：
		（1）call_user_func	调用类内部的方法，并传参数。
			一、如：call_user_func(array("a", "b"),"111"); 调用a类的b方法，参数为111
		（2）call_user_func_array			
			一、调用函数,并传参数：call_user_func_array('a', array("111", "222")); 调用a函数，第一个参数为111,第二个参数为222
			二、调用类内部的方法，并传参数。call_user_func_array(array('ClassA','b'), array("111", "222")); 
8、错误异常与调式
	1）错误级别：
		（1）Notice 通知级别的错误 如直接使用未声明变量，程序继续执行
　		（2）Warning 警告级别的错误，可能得不到想要的结果
　		（3）Fatal error  致命级别错误致命级别错误，程序不往下执行
　		（4）parse error 语法解析错误，最高级别错误，连其他错误信息也不呈现出来
		（5）补充说明：
			一、http://blog.csdn.net/zhang197093/article/details/75094816
			二、http://blog.sina.com.cn/s/blog_558839ae0100es0u.html
			三、php的错误分成了很多的级别，如E_ERROR、E_WARNING、E_PARSE、E_NOTICE等等，对于像E_ERROR、E_PARSE这样的严重错误不能被用户自定义处理，php会直接终止脚本的运行。
	2）php错误异常处理内置函数
		（1）set_error_handler
			一、定义：设置用户自定义的错误处理函数。 该函数用于创建运行时期间的用户自己的错误处理方法，用来捕捉错误级别为Warning或Notice的错误，E_ERROR、E_PARSE级别的错误无法捕捉
			二、用法：
				（一）、不仅可以接受函数，还可以接受 类的方法（公开的静态方法 及 公开的非静态方法 都可以），但需要以 数组形式 传递，数组的第一值为“类名”，第二个参数为“方法名
				（二）、例：set_error_handler（'func'）或set_error_handler（['classA','method']）
			三、提示：如果使用了该函数，会完全绕过标准的 PHP 错误处理函数，			
		（2）set_exception_handler
			一、定义：设置用户自定义的异常处理函数,只要有异常抛出（throw new Exception），就会被触发
			二、用法：同上
		（3）register_shutdown_function
			一、定义：PHP程序执行完成后执行的函数，原理就是在PHP进程结束前会去调用它一次（在页面的最后）
			二、触发情况分为以下几种使用场景：
				（一）、php代码执行过程中发生错误（异常或错误），成功、die、exit等（调试时会看到在die后有输出）
				（二）、php代码运行超时
				（三）、页面被（用户）强制停止
	3）ErrorException与HttpException
		（1）ErrorException对错误处理，HttpException对异常处理	
		（2）ErrorException会记录日志并且渲染异常模板，HttpException只渲染异常模板（tpAdmin-master/thinkphp/tpl/think_exception.tpl）
	4）调式：
		（1）性能调式：调试某段代码的运行时间（单位s）或者内存占用开销(单位kb)
			一、debug('begin'); ...代码段；debug('end');   echo debug('begin','end').'s';   echo debug('begin','end').'kb';	
9、配置：
	1）环境变量中的配置优先于项目应用的配置文件
	2）配置文件初始化配置流程说明：
		1）config::load($file,$name)函数会载入配置文件，如果载入的文件是config.php，则$name为空，否则$name为配置文件名。如：
			一、Config::load(‘tpAdmin-master\application\database.php’ 'database');载入数据库配置文件
			二、Config::load(‘tpAdmin-master\application\extra\captcha.php’ 'captcha');载入验证码配置文件	
		2）载入配置文件后，调用config::set()函数对配置文件中的数据进行合并！（如果有设置$name,则$name就是数组中的键）
		3）读取配置文件：config::get('database')数据库配置文件database.php中的数据，config::get('session')配置文件config.php中的session数据，
10、日志
	1）运行流程：App.php执行过程中有Log::record()函数对日志信息初始化，只要程序执行完成，就会触发php内置函数register_shutdown_function（在error.php），里面有个Log::save()
	2）Log::record()与Log::write（）区别：
		(1)、Log::record要等到程序执行完成才写入（Log::save），Log::write实时写入（方法里面直接调用Log::save）	
	3)__callStatic： 当调用的静态方法不存在或权限不足时，会自动调用__callStatic方法。
		（1）如：Log::error（'错误信息'）相当于Log::record('错误信息','error');      Log::info('日志信息')相当于Log::record('日志信息','info');
		（2）与__call方法区别：__call 当要调用的方法不存在或权限不足时，会自动调用__call 方法。
	4)独立日志：config.php配置文件log数组中设置'apart_level'   =>  ['error','sql'],会单独生成以日期天数为前缀 error 和 sql两个类型的日志文件，主日志文件中将不再包含这两个级别的日志信息
11、命令行
        1）自动生成目录结构（整个完整项目模块）
12、杂项
        1）缓存：
                （1）配置多个缓存类型
                        一、config.php配置文件cache数组中,设置'type' => 'complex',通过cache::store('file')->set('name','value')或cache::store('redis')->set('name','value')就可以切换到不同的缓存类型存储数据
        2）session
                (1)use_trans_sid
                        一、浏览器禁用cookie后php如何保持session会话use_trans_sid机制（http://blog.csdn.net/wzxsjdt/article/details/50508240）
                        二、Session变量不能传送到下一页.解决: session.use_trans_sid = 1（http://blog.csdn.net/drylandfish/article/details/244085?%3E）
                (2)session_id()与session_name()
                        一、赋值：session_id('123'),把PHPSESSID赋值为'123'
                        二、获取：session_id（）；获取 PHPSESSID的值
                        三、session_name()获取的值为'PHPSESSID'，用法与session_id（）一样，都是进行设置值与获取值
                (3)session_unset()和session_destroy()区别
                        一、session_unset()释放当前在内存中已经创建的所有$_SESSION变量，但不删除session文件以及不释放对应的session_id
                        二、session_destroy()删除当前用户对应的session文件以及释放session_id，内存中的$_SESSION变量内容依然保留
        3）cookie                
                (1) 
	4）验证码
		（1）运行流程： 
			一、首先使用Composer安装think-captcha扩展包：composer require topthink/think-captcha
			二、在tpAdmin-master\vendor\topthink\think-captcha\src\helper.php有设置路由
				（一）、\think\Route::get('captcha/[:id]', "\\think\\captcha\\CaptchaController@index");
			三、在\tpAdmin-master\vendor\composer\autoload_psr4.php有注册验证码命名空间
				（一）、'think\\captcha\\' => array($vendorDir . '/topthink/think-captcha/src'),
			四、生成验证码并保存在session中
		（2）登录时验证码校验：
			一、在tpAdmin-master\vendor\topthink\think-captcha\src\helper.php中有一个验证函数。对输入的验证码与生成的验证码进行校验比对
				（一）\think\Validate::extend('captcha', function ($value, $id = "") {
					return captcha_check($value, $id, (array)\think\Config::get('captcha'));
				       });
		（3）tpAdmin-master\vendor\topthink\think-captcha\src\helper.php这个文件何时加载进来执行的？
			一、tpAdmin-master\thinkphp\library\think\Load.php中有注册composer自动加载，有加载autoload_files.php文件，此文件有helper.php
13、数据库
        1）Db::query（）与Db::execute（）执行原理
                （1）Db.php中有一个__callStatic方法，调用未定义的方法会去连接的数据库类（或父类Connection.php）中查找
                （2）区别：Db::query方法用于执行SQL查询操作，Db::execute用于更新和写入数据的sql操作
        2)Db::table()与Db::name()执行原理
                （1）Db.php中有一个__callStatic方法（未定义的方法会去\think\db\Connection.php中找）
                （2）Connection.php中有一个__call方法（未定义的方法会去\think\db\Query.php中找）   
                （3）区别：Db::table('think_user')表要加前缀，Db::name('user')不用表前缀
        3)sql调试与监听
                (1)如果数据库配置文件有开启debug,则会对sql进行调试(把sql语句、sql性能分析、sql运行时间等信息写入日志)或监听
                （2）监听：Db::listen();
14、模型
        1）

      
15、函数：
	1）method_exists()与is_callable()的区别
		（1）、一个方法存在并不意味着它就可以被调用。对于 private，protected和public类型的方法，method_exits()会返回true，但是is_callable()会检查存在其是否可以访问，如果是private，protected类型的，它会返回false
        2)array_diff()
                （1）比较两个数组的值，并返回差集。返回两个数组的差集数组。该数组包括了所有在被比较的数组中，但是不在任何其他参数数组中的键值。在返回的数组中，键名保持不变。
        3）array_walk()与 array_walk_recursive() 用法与区别
                （1）array_walk()：使用用户自定义函数对数组中的每个元素做回调处理 （对数组中的每个元素应用用户自定义函数。在函数中，数组的键名和键值是参数。）
                        一、语法：array_walk(array,myfunction,userdata...)
                （2）array_walk_recursive() ：比array_walk操作更深的数组（一个数组中包含另一个数组）
        4）array_change_key_case()
                （1）函数将数组的所有的键都转换为大写字母或小写字母。如果未提供可选参数（即第二个参数），则默认转换为小写字母。
                （2）语法：array_change_key_case(array,case);case可以为CASE_LOWER（小写）或CASE_UPPER（大写）
	5)parse_url
		（1）定义：解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分 
		（2）用法：parse_url('http://username:password@hostname/path?arg=value#anchor')	
                        一、返回Array ( [scheme] => http [host] => hostname [user] => username [pass] => password [path] => /path [query] => arg=value [fragment] => anchor ) 
        6)parse_str()函数：把查询字符串解析到变量中。
                        一、如：parse_str("name=Bill&age=60",$myArray);     //$myArray数组结果为Array ( [name] => Bill [age] => 60 )
        7) get_object_var($object)，返回一个数组。获取$object对象中的属性，组成一个数组
        8)  __CLASS__、get_class()都是获取当前的类名。
            但是get_class($this)与get_called_class()都是获取主调类的类名（就是调用者的类名）


